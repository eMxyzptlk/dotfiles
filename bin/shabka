#! /usr/bin/env bash

set -euo pipefail

echoErr() { >&2 echo "ERR: ${*}" ; }
echoWarn() { >&2 echo "WARN: ${*}" ; }
echoInfo() { >&2 echo "INFO: ${*}" ; }
echoSuccess() { >&2 echo "SUCCESS: ${*}" ; }
containsElement() {
  declare -r to_find="${1}"; shift 1
  for element in "${@}"; do [[ "${element}" == "${to_find}" ]] && return 0; done
  return 1
}

echoUsage() {
  >&2 echo "TODO"
}

setShabkaPath() {
  desc="TODO"

  # TODO: always get the shabka path from a default location/channel
  declare -g -r shabka_path="$(cd $(dirname "${BASH_SOURCE[0]}")/../ && pwd)"
}

setDotshabkaPath() {
  desc="TODO"

  # TODO: change this to be the default path of .shabka
  if [[ "x$(printenv DOTSHABKA_PATH)" == "x" ]]; then
    echoErr "Please define DOTSHABKA_PATH to point to the location of your .shabka."
    exit 1
  fi

  declare -g -r dotshabka_path="${DOTSHABKA_PATH}"

  if ! [[ -d "${dotshabka_path}" ]]; then
    echoErr "DOTSHABKA_PATH: ${dotshabka_path}: No such directory."
    exit 1
  fi
}

getHostRelease() {
  desc="Get the release of a host, defaults to shabka's release.
        Usage: getHostRelease <host>
        Requires shabka_path and dotshabka_path to be set."

  declare -r host="${1}"
  shift 1

  if [[ -r "${dotshabka_path}/hosts/${host}/release" ]]; then
    declare -r host_release="$( cat "${dotshabka_path}/hosts/${host}/release" )"
  else
    # fallback to shabka's default release
    declare -r host_release="$( tr -d "\n" < "${shabka_path}/release" )"
  fi

  echo "${host_release}"

  #export RELEASE="release-${release/./-}"
}

getHostUname() {
  desc="Get the uname of a host.
        Usage: getHostUname <host>
        Requires dotshabka_path to be set."

  declare -r host="${1}"
  shift 1

  if [[ -r "${dotshabka_path}/hosts/${host}/uname" ]]; then
    declare -g -r host_uname="$( cat "${dotshabka_path}/hosts/${host}/uname" )"
  else
    echoErr "Required file does not exist: ${dotshabka_path}/hosts/${host}/uname"
    exit 1
  fi

  case "${host_uname}" in
    "Darwin"|"NixOS")
      echo "${host_uname}"
      ;;
    "Linux")
      echoErr "Linux non-NixOS hosts not supported yet."
      exit 1
      ;;
    *)
      echoErr "Invalid value ${host_uname} at
               ${dotshabka_path}/hosts/${host}/uname"
      exit 1
      ;;
  esac
}

getNixPath() {
  desc="Compute the NIX_PATH from release and uname.
        Usage: getNixPath <release> <uname>
        Requires shabka_path to be set."

  declare -r release="${1}"
  declare -r uname="${2}"
  shift 2

  declare -r nixpkgs="$( nix-build --no-out-link "${shabka_path}" \
                         -A "external.nixpkgs.release-${release/./-}.path" )"
  declare nix_path="nixpkgs=${nixpkgs}:shabka=${shabka_path}"

  if [[ -z "${uname:-}" ]] || [[ "${uname}" == "Darwin" ]]; then
    declare -r nix_darwin="$( nix-build --no-out-link "${shabka_path}" \
                              -A "external.nix-darwin.path" )"
    declare nix_path="darwin=${nix_darwin}:${NIX_PATH}"
  fi

  echo "${nix_path}"
}

getConfigPath() {
  desc="Get the configuration.nix path for a host.
        Usage: getConfigPath <host>
        Requires dotshabka_path to be set."

  declare -r host="${1}"
  shift 1

  declare -r config_path="${dotshabka_path}/hosts/${host}/configuration.nix"
  if ! [[ -r "${config_path}" ]]; then
    echoErr "Configuration ${config_path} does not exist."
    exit 1
  fi

  echo "${config_path}"
}

executeBuild() {
  desc="Build a host.
        Usage: executeBuild <host> <release> [nix-build arguments and options]
        Requires shabka_path and dotshabka_path to be set."

  declare -r host="${1}"
  declare release="${2}"
  shift 2

  if [[ -z "${release:-}" ]]; then
    declare -r release="$( getHostRelease "${host}" )"
  else
    declare -r release="${release}"
  fi
  export RELEASE="release-${release/./-}"

  declare -r uname="$( getHostUname "${host}" )"

  export NIX_PATH="$( getNixPath "${release}" "${uname}" )"

  nix-build --option builders '' "${dotshabka_path}/hosts/${host}" -A system "${@}"
}

executeRebuild() {
  desc="Rebuild a host.
        Usage: executeRebuild <command> <host> <release> [nixos-build arguments and options]
        Requires shabka_path and dotshabka_path to be set."

  declare -r cmd="${1}"
  declare -r host="${2}"
  declare -r release="${3}"
  shift 3

  if [[ -z "${release:-}" ]]; then
    declare -r release="$( getHostRelease "${host}" )"
  else
    declare -r release="${release}"
  fi
  export RELEASE="release-${release/./-}"

  declare -r uname="$( getHostUname "${host}" )"

  export NIX_PATH="$( getNixPath "${release}" "${uname}" )"

  case "${uname}" in
    "NixOS")
      setNixosConfigPath
      nixos-rebuild -I "nixos-config=$( getConfigPath "${host}" )" "${command}" "${@}"
      ;;
    "Darwin")
      setDarwinConfigPath
      darwin-rebuild -I "darwin-config=$( getConfigPath "${host}" )" "${command}" "${@}"
      ;;
    # For future use
    "Linux")
      ;;
  esac
}

main() {
  if [[ "$#" -eq 0 ]]; then
    echoUsage
    exit 1
  fi

  declare host="$( hostname -s )"
  declare release=

  while getopts ":h:r:" opt; do
      case "${opt}" in
        h)
          declare host="${OPTARG}"
          ;;
        r)
          declare release="${OPTARG}"
          ;;
        :)
          echoErr "Invalid option: $OPTARG requires an argument"
          echoUsage
          exit 1
          ;;
        \?)
          # end of possible arguments, rest are for the command
          break
          ;;
      esac
  done
  shift $((OPTIND -1))

  declare -r host="${host}"
  declare -r release="${release}"

  declare -r command="${1}"
  shift 1

  setShabkaPath
  setDotshabkaPath

  case "${command}" in
    help)
      echoUsage
      exit 0
      ;;
    build)
      executeBuild "${host}" "${release}" "${@}"
    ;;
    switch|boot|test|dry-build|dry-activate|activate|check)
      executeRebuild "${command}" "${host}" "${release}" "${@}"
      ;;
#    push-to-cachix)
#      # Command is the cache name here, the rest are hosts
#      executePushToCachix "${command}" "${@}"
#      ;;
    *)
      echoErr "Unkown command:Â $command"
      echoUsage
      exit 1
      ;;
  esac
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@" || true
